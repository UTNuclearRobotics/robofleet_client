#include <{msg_package}_robofleet/{msg_name}.h>
#include <QByteArray>

{msg_package}::{msg_name} FbtoRos(const fb::{msg_package}::{msg_name}* src)
{{
  {msg_package}::{msg_name} msg;{msg_decode_assignments}

  return msg;
}}

std::vector<{msg_package}::{msg_name}> FbtoRos(const flatbuffers::Vector<flatbuffers::Offset<fb::{msg_package}::{msg_name}>>* src)
{{
  std::vector<{msg_package}::{msg_name}> dst;
  dst.reserve(src->size());
  typedef flatbuffers::Vector<flatbuffers::Offset<fb::{msg_package}::{msg_name}>> fvec;
  for (fvec::const_iterator it = src->begin(); it != src->end(); ++it)
  {{
    dst.push_back(FbtoRos(*it));
  }}

  return dst;
}}

flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::{msg_package}::{msg_name}>>> RostoFb(flatbuffers::FlatBufferBuilder& fbb, const std::vector<{msg_package}::{msg_name}>& src)
{{
  std::vector<flatbuffers::Offset<fb::{msg_package}::{msg_name}>> dst(src.size());
  std::transform(
      src.begin(), src.end(), dst.begin(), [&fbb](const {msg_package}::{msg_name}& item) {{
        return RostoFb(fbb, item);
      }});
  return fbb.CreateVector(dst).o;
}}

flatbuffers::Offset<fb::{msg_package}::{msg_name}> RostoFb(flatbuffers::FlatBufferBuilder& fbb, const {msg_package}::{msg_name}& msg)
{{
  return fb::{msg_package}::Create{msg_name}(fbb, 0{msg_encode_assignments}).o;
}}

namespace {msg_package}_robofleet {{

  bool {msg_name}SrvInHandler::initialize(ros::NodeHandle& nh,
                                                   MessageScheduler* scheduler,
                                                   const std::string service_name)
  {{
    if (!robofleet_client::ROSSrvInHandler::initialize(nh,
                                                         scheduler,
                                                         service_name)) {{
      return false;
    }}

    flatbuffers::FlatBufferBuilder fbb;
    typedef MetaDataOffset (*func_type)(flatbuffers::FlatBufferBuilder&,
                                       flatbuffers::Offset<flatbuffers::String>,
                                       flatbuffers::Offset<flatbuffers::String>);
    encode_metadata_function_ = std::bind(static_cast<func_type>(&fb::CreateMsgMetadata),
                                          std::placeholders::_1,
                                          fbb.CreateString("{msg_package}::{msg_name}"),
                                          fbb.CreateString(to_topic.c_str()));

    sub_ = nh.serviceClient<SrvType>(to_topic, 10, &{msg_name}SrvInHandler::callback, this);

    return true;
  }}

  
  QByteArray {msg_name}SrvInHandler::encodeWithMetadata(const MsgType& msg)
  {{
    flatbuffers::FlatBufferBuilder fbb;

    // encode the metadata
    const MetaDataOffset metadata = encode_metadata_function_(fbb);

    const flatbuffers::uoffset_t root_offset =
          fb::{msg_package}::Create{msg_name}(fbb,
                                              metadata{msg_encode_assignments}).o;

    fbb.Finish(flatbuffers::Offset<void>(root_offset));
    const QByteArray data{{reinterpret_cast<const char*>(fbb.GetBufferPointer()),
                          static_cast<int>(fbb.GetSize())}};

    return data;
  }}
  
  QByteArray {msg_name}SrvInHandler::encode(const MsgType& msg)
  {{
    flatbuffers::FlatBufferBuilder fbb;

    // not including metadata
    const MetaDataOffset metadata = 0;

    const flatbuffers::uoffset_t root_offset =
          fb::{msg_package}::Create{msg_name}(fbb,
                                              metadata{msg_encode_assignments}).o;

    fbb.Finish(flatbuffers::Offset<void>(root_offset));
    const QByteArray data{{reinterpret_cast<const char*>(fbb.GetBufferPointer()),
                          static_cast<int>(fbb.GetSize())}};

    return data;
  }}

  bool {msg_name}SrvInHandler::callback(const RequestType::ConstPtr& req, const ResponseType::ConstPtr& res)
  {{
    const QByteArray data = encodeWithMetadata(*req);
    schedule_function_(data);

    // spin until we get a response
    // assign result to res

    return true;
  }}
}} // namespace {msg_package}_robofleet

PLUGINLIB_EXPORT_CLASS({msg_package}_robofleet::{msg_name}SrvInHandler, robofleet_client::ROSSrvInHandler)