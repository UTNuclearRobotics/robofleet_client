#pragma once

// the plugin parent class
#include <robofleet_client/ROSMsgHandlers.hpp>

// get the msg type
#include <{msg_package}/{msg_name}.h>

#include <{msg_package}_robofleet/schema_generated.h>

namespace {msg_package}_robofleet {{

  /** Conversion Functions **/
  {msg_package}::{msg_name} FbtoRos(const fb::{msg_package}::{msg_name}* src);

  {msg_package}::{msg_name} FbtoRos(const fb::{msg_package}::{msg_name}& src_ref);

  std::vector<{msg_package}::{msg_name}> FbtoRos(const std::vector<fb::{msg_package}::{msg_name}>* src);

  std::vector<{msg_package}::{msg_name}> FbtoRos(const flatbuffers::Vector<flatbuffers::Offset<fb::{msg_package}::{msg_name}>>* src);

  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::{msg_package}::{msg_name}>>> RostoFb(flatbuffers::FlatBufferBuilder& fbb, const std::vector<{msg_package}::{msg_name}>& msg);

  flatbuffers::Offset<fb::{msg_package}::{msg_name}> RostoFb(flatbuffers::FlatBufferBuilder& fbb, const {msg_package}::{msg_name}& msg);

  /** Publish Handler **/
  class {msg_name}PublishHandler : public robofleet_client::ROSPublishHandler
  {{
  public:

    // advertises the topic
    virtual void initialize(ros::NodeHandle& nh,
                            const std::string to_topic,
                            const bool latched);
    
    // decodes raw data into the flatbuffer type,
    // then converts to the ROS type, then publishes to the topic
    virtual void publish(const QByteArray& data);

  private:
    typedef {msg_package}::{msg_name} MsgType;
    typedef fb::{msg_package}::{msg_name} FbMsgType;

    // converts from raw data to flatbuffer type
    const FbMsgType* decode(const QByteArray& data);
  }};
  
  
  /** Subscribe Handler **/
  class {msg_name}SubscribeHandler : public robofleet_client::ROSSubscribeHandler
  {{
  public:
    typedef {msg_package}::{msg_name} MsgType;

    // sets up subscriber, message scheduler function, and metadata function
    virtual bool initialize(ros::NodeHandle& nh,
                              MessageScheduler* scheduler,
                              const std::string to_topic,
                              const double priority,
                              const double rate_limit,
                              const bool no_drop);

    // converts from flatbuffer type to raw data
    static QByteArray encode(const MsgType& msg);
    
  private:
    typedef boost::shared_ptr<MsgType> MsgTypeConstPtr;
    typedef flatbuffers::Offset<fb::MsgMetadata> MetaDataOffset;
    
    // loads metadata into the flatbuffer builder
    std::function<MetaDataOffset(flatbuffers::FlatBufferBuilder&)> encode_metadata_function_;

    // produces a buffer with metadata
    QByteArray encodeWithMetadata(const MsgType& msg);
    
    // encodes the message
    void callback(const MsgTypeConstPtr& msg);
  }};
}}