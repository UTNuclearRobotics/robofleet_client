#include <{msg_package}_robofleet/{msg_name}.h>
#include <QByteArray>

// message dependencies
{dependencies}

namespace {msg_package}_robofleet {{

  // explicitly handle arrays of primitive types
  template<class PrimType>
  flatbuffers::Offset<flatbuffers::Vector<PrimType>> RostoFb(flatbuffers::FlatBufferBuilder& fbb, const std::vector<PrimType>& src)
  {{
    return fbb.CreateVector(src);
  }}

  template<class PrimType>
  std::vector<PrimType> FbtoRos(const flatbuffers::Vector<PrimType>* src)
  {{
    return std::vector<PrimType>(src->begin(), src->end());
  }}

  // time and duration primitives don't follow the usual pattern,
  // so handle them explicitly
  ros::Time FbtoRos(const fb::RosTime* fb)
  {{
    return ros::Time(fb->sec(), fb->nsec());
  }}

  fb::RosTime RosToFb(const ros::Time& msg)
  {{
    return fb::RosTime(msg.sec, msg.nsec);
  }}

  ros::Duration FbtoRos(const fb::RosDuration* fb)
  {{
    return ros::Duration(fb->sec(), fb->nsec());
  }}

  fb::RosDuration RosToFb(const ros::Duration& msg)
  {{
    return fb::RosDuration(msg.sec, msg.nsec);
  }}

  {msg_package}::{msg_name} FbtoRos(const fb::{msg_package}::{msg_name}* src)
  {{
    {msg_package}::{msg_name} msg;{msg_decode_assignments}

    return msg;
  }}

  std::vector<{msg_package}::{msg_name}> FbtoRos(const flatbuffers::Vector<fb::{msg_package}::{msg_name}>* src)
  {{
    std::vector<{msg_package}::{msg_name}> dst(src->size());
    std::transform(
        src->begin(), src->end(), dst.begin(), [](const fb::{msg_package}::{msg_name}& item) {{
          return FbtoRos(&item);
        }});

    return dst;
  }}

  std::vector<{msg_package}::{msg_name}> FbtoRos(const flatbuffers::Vector<flatbuffers::Offset<fb::{msg_package}::{msg_name}>>* src)
  {{
    std::vector<{msg_package}::{msg_name}> dst(src->size());
    std::transform(
        src->begin(), src->end(), dst.begin(), [](const fb::{msg_package}::{msg_name}& item) {{
          return FbtoRos(&item);
        }});

    return dst;
  }}

  flatbuffers::Offset<flatbuffers::Vector<{msg_name}Offset>> RostoFb(flatbuffers::FlatBufferBuilder& fbb, const std::vector<{msg_package}::{msg_name}>& src)
  {{
    std::vector<{msg_name}Offset> dst(src.size());
    std::transform(
        src.begin(), src.end(), dst.begin(), [&fbb](const {msg_package}::{msg_name}& item) {{
          return RostoFb(fbb, item);
        }});
    return fbb.CreateVector(dst).o;
  }}

  {msg_name}Offset RostoFb(flatbuffers::FlatBufferBuilder& fbb, const {msg_package}::{msg_name}& msg)
  {{
    return fb::{msg_package}::Create{msg_name}(fbb, 0{msg_encode_assignments}).o;
  }}
    
  void {msg_name}PublishHandler::initialize(ros::NodeHandle& nh,
                                                 const std::string to_topic,
                                                 const bool latched)
  {{
    pub_ = nh.advertise<MsgType>(to_topic,
                                 10,
                                 latched);
  }}

  const {msg_name}PublishHandler::FbMsgType*
  {msg_name}PublishHandler::decode(const QByteArray& data)
  {{
    const fb::{msg_package}::{msg_name}* root = 
      flatbuffers::GetRoot<fb::{msg_package}::{msg_name}>(data.data());

    return root;
  }}
  
  void {msg_name}PublishHandler::publish(const QByteArray& data)
  {{
    const FbMsgType* fb = decode(data);
    const MsgType msg = FbtoRos(fb);
    
    pub_.publish(msg);
  }}

  PLUGINLIB_EXPORT_CLASS({msg_package}_robofleet::{msg_name}PublishHandler, robofleet_client::ROSPublishHandler)
  


  bool {msg_name}SubscribeHandler::initialize(ros::NodeHandle& nh,
                                                   MessageScheduler* scheduler,
                                                   const std::string to_topic,
                                                   const double priority,
                                                   const double rate_limit,
                                                   const bool no_drop)
  {{
    if (!robofleet_client::ROSSubscribeHandler::initialize(nh,
                                                           scheduler,
                                                           to_topic,
                                                           priority,
                                                           rate_limit,
                                                           no_drop)) {{
      return false;
    }}

    flatbuffers::FlatBufferBuilder fbb;
    typedef MetaDataOffset (*func_type)(flatbuffers::FlatBufferBuilder&,
                                       flatbuffers::Offset<flatbuffers::String>,
                                       flatbuffers::Offset<flatbuffers::String>);
    encode_metadata_function_ = std::bind(static_cast<func_type>(&fb::CreateMsgMetadata),
                                          std::placeholders::_1,
                                          fbb.CreateString("{msg_package}::{msg_name}"),
                                          fbb.CreateString(to_topic.c_str()));

    sub_ = nh.subscribe(to_topic, 10, &{msg_name}SubscribeHandler::callback, this);

    return true;
  }}

  
  QByteArray {msg_name}SubscribeHandler::encodeWithMetadata(const MsgType& msg)
  {{
    flatbuffers::FlatBufferBuilder fbb;

    // encode the metadata
    const MetaDataOffset metadata = encode_metadata_function_(fbb);

    const flatbuffers::uoffset_t root_offset =
          fb::{msg_package}::Create{msg_name}(fbb,
                                              metadata{msg_encode_assignments}).o;

    fbb.Finish(flatbuffers::Offset<void>(root_offset));
    const QByteArray data{{reinterpret_cast<const char*>(fbb.GetBufferPointer()),
                          static_cast<int>(fbb.GetSize())}};

    return data;
  }}
  
  QByteArray {msg_name}SubscribeHandler::encode(const MsgType& msg)
  {{
    flatbuffers::FlatBufferBuilder fbb;

    // not including metadata
    const MetaDataOffset metadata = 0;

    const flatbuffers::uoffset_t root_offset =
          fb::{msg_package}::Create{msg_name}(fbb,
                                              metadata{msg_encode_assignments}).o;

    fbb.Finish(flatbuffers::Offset<void>(root_offset));
    const QByteArray data{{reinterpret_cast<const char*>(fbb.GetBufferPointer()),
                          static_cast<int>(fbb.GetSize())}};

    return data;
  }}

  void {msg_name}SubscribeHandler::callback(const MsgTypeConstPtr& msg)
  {{
    const QByteArray data = encodeWithMetadata(*msg);
    schedule_function_(data);
  }}
}} // namespace {msg_package}_robofleet

PLUGINLIB_EXPORT_CLASS({msg_package}_robofleet::{msg_name}SubscribeHandler, robofleet_client::ROSSubscribeHandler)